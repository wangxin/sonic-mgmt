import copy
import time
import json
import logging
import tempfile
import random

from collections import defaultdict
from datetime import datetime

import pytest
import requests

from tests.common.fixtures.ptfhost_utils import copy_ptftests_directory   # lgtm[py/unused-import]
from tests.ptf_runner import ptf_runner
from tests.common.helpers.assertions import pytest_assert
from tests.common.dualtor.dualtor_utils import mux_server_url

logger = logging.getLogger(__name__)

pytestmark = [
    pytest.mark.topology('any')
]

# Usually src-mac, dst-mac, vlan-id are optional hash keys. Not all the platform supports these optional hash keys. Not enable these three by default.
# HASH_KEYS = ['src-ip', 'dst-ip', 'src-port', 'dst-port', 'ingress-port', 'src-mac', 'dst-mac', 'ip-proto', 'vlan-id']
HASH_KEYS = ['src-ip', 'dst-ip', 'src-port', 'dst-port', 'ingress-port', 'ip-proto']
SRC_IP_RANGE = ['8.0.0.0', '8.255.255.255']
DST_IP_RANGE = ['9.0.0.0', '9.255.255.255']
SRC_IPV6_RANGE = ['20D0:A800:0:00::', '20D0:A800:0:00::FFFF']
DST_IPV6_RANGE = ['20D0:A800:0:01::', '20D0:A800:0:01::FFFF']
VLANIDS = range(1032, 1279)
VLANIP = '192.168.{}.1/24'
PTF_QLEN = 2000
DEFAULT_MUX_SERVER_PORT = 8080

FIB_SETUP_INFO_PATH = '/root/test_fib_setup_hash.json'
PTF_PORT_DUT_MAP_PATH = '/root/ptf_port_dut_map.json'


@pytest.fixture(scope='module')
def ptf_port_dut_map(tbinfo):
    """Get a map from PTF port number to DUT numbers.

    In multi DUT scenario, PTF ports may be connected to different DUTs. In dualtor scenario, a PTF port may be
    connected to two different DUTs through Y cable.

    Args:
        tbinfo (dict): Testbed info generated by the tbinfo fixture.

    Returns:
        dict: Map from ptf port index to DUT index number. PTF ports that are connected to disabled DUT interface are
        not included. For example:
            {
                '1': [0, 1],
                '2': [0, 1],
                ...
                '32': [0],
                '33': [1],
                ...
            }
    """
    ptf_map = tbinfo['topo']['ptf_map']
    result = defaultdict(list)
    for dut_index, map in ptf_map.items():
        for dut_port_index, ptf_port_index in map.items():
            if dut_index not in result[str(ptf_port_index)]:
                result[str(ptf_port_index)].append(int(dut_index))
    return result


@pytest.fixture(scope='module')
def config_facts(duthosts):
    return duthosts.config_facts(source='running')


@pytest.fixture(scope='module')
def minigraph_facts(duthosts, tbinfo):
    return duthosts.get_extended_minigraph_facts(tbinfo)


def get_fib_info(duthost, cfg_facts, mg_facts):
    """Get parsed FIB information from redis DB.

    Args:
        duthost (SonicHost): Object for interacting with DUT.
        cfg_facts (dict): Configuration facts.
        mg_facts (dict): Minigraph facts.

    Returns:
        dict: Map of prefix to PTF ports that are connected to DUT output ports.
            {
                '192.168.0.0/21': [],
                '192.168.8.0/25': [[58 59] [62 63] [66 67] [70 71]],
                '192.168.16.0/25': [[58 59] [62 63] [66 67] [70 71]],
                ...
                '20c0:c2e8:0:80::/64': [[58 59] [62 63] [66 67] [70 71]],
                '20c1:998::/64': [[58 59] [62 63] [66 67] [70 71]],
                ...
            }
    """
    timestamp = datetime.now().strftime('%Y-%m-%d-%H:%M:%S')
    duthost.shell("redis-dump -d 0 -k 'ROUTE*' -y > /tmp/fib.{}.txt".format(timestamp))
    duthost.fetch(src="/tmp/fib.{}.txt".format(timestamp), dest="/tmp/fib")

    po = cfg_facts.get('PORTCHANNEL', {})
    ports = cfg_facts.get('PORT', {})

    fib_info = {}
    with open("/tmp/fib/{}/tmp/fib.{}.txt".format(duthost.hostname, timestamp)) as fp:
        fib = json.load(fp)
        for k, v in fib.items():
            skip = False

            prefix = k.split(':', 1)[1]
            ifnames = v['value']['ifname'].split(',')
            nh = v['value']['nexthop']

            oports = []
            for ifname in ifnames:
                if po.has_key(ifname):
                    oports.append([str(mg_facts['minigraph_ptf_indices'][x]) for x in po[ifname]['members']])
                else:
                    if ports.has_key(ifname):
                        oports.append([str(mg_facts['minigraph_ptf_indices'][ifname])])
                    else:
                        logger.info("Route point to non front panel port {}:{}".format(k, v))
                        skip = True

            # skip direct attached subnet
            if nh == '0.0.0.0' or nh == '::' or nh == "":
                skip = True

            if not skip:
                fib_info[prefix] = oports
            else:
                fib_info[prefix] = []
    return fib_info


def gen_fib_info_file(ptfhost, fib_info, filename):
    tmp_fib_info = tempfile.NamedTemporaryFile()
    for prefix, oports in fib_info.items():
        tmp_fib_info.write(prefix)
        if oports:
            for op in oports:
                tmp_fib_info.write(' [{}]'.format(' '.join(op)))
        else:
            tmp_fib_info.write(' []')
        tmp_fib_info.write('\n')
    tmp_fib_info.flush()
    ptfhost.copy(src=tmp_fib_info.name, dest=filename)


def get_duts_ptf_ports(tbinfo):
    """Get a map between DUT index and list of PTF ports connected to it.

    Args:
        tbinfo (dict): Parsed testbed information from the tbinfo fixture.

    Returns:
        dict: Key is dut_index. Value is list of PTF ports that are connected to DUT's enabled ports. Example:
            {
                '0: [0, 1, 2, 3, ...],
                '1': [32, 33, 34, ...]
            }
    """
    ptf_map = tbinfo['topo']['ptf_map']
    result = defaultdict(list)
    for dut_index, map in ptf_map.items():
        for dut_port_index, ptf_port_index in map.items():
            if dut_port_index in tbinfo['topo']['ptf_map_disabled'][dut_index].keys():
                continue
            result[dut_index].append(ptf_port_index)
    return result


@pytest.fixture(scope='module')
def setup_fib(duthosts, ptfhost, config_facts, minigraph_facts, tbinfo, request):

    logger.info(json.dumps(tbinfo))
    logger.info(json.dumps(minigraph_facts))

    fib_info_files = []
    router_mac = {}
    vlan_mac = defaultdict(list)
    vlan_ports = defaultdict(list)
    for duthost in duthosts:
        fib_info = get_fib_info(duthost, config_facts[duthost.hostname], minigraph_facts[duthost.hostname])
        dut_index = str(tbinfo['duts_map'][duthost.hostname])
        filename = '/root/fib_info_dut{}.txt'.format(dut_index)
        gen_fib_info_file(ptfhost, fib_info, filename)
        fib_info_files.append(filename)

        router_mac[dut_index] = duthost.facts['router_mac']

        for v in config_facts[duthost.hostname].get('VLAN', {}).values():
            if 'mac' in v:
                vlan_mac[dut_index].append(v['mac'])
            else:
                vlan_mac[dut_index].append(duthost.facts['router_mac'])

        for v in config_facts[duthost.hostname].get('VLAN_MEMBER', {}).values():
            for intf in v.keys():
                dut_port_index = str(config_facts[duthost.hostname]['port_index_map'][intf])
                vlan_port = tbinfo['topo']['ptf_map'][dut_index][dut_port_index]
                if vlan_port not in vlan_ports[dut_index]:
                    vlan_ports[dut_index].append(vlan_port)

    duts_ptf_ports = get_duts_ptf_ports(tbinfo)

    setup_info = {
        'fib_info_files': fib_info_files,
        'duts_ptf_ports': duts_ptf_ports,
        'router_mac': router_mac,
        'vlan_mac': vlan_mac,
        'vlan_ports': vlan_ports,
        'tbinfo': tbinfo
    }
    logger.info('setup_info: {}'.format(json.dumps(setup_info)))

    ptfhost.copy(content=json.dumps(setup_info), dest=FIB_SETUP_INFO_PATH)
    yield FIB_SETUP_INFO_PATH


def set_dualtor_active(url, side):
    res = requests.post(url, json={"active_side": side})
    pytest_assert(res.status_code==200, 'Failed to set active side: {}'.format(res.text))
    return res.json()   # Response is new mux_status of all mux Y-cables.


def remove_inactive_side_dut(map, tbinfo, mux_status):
    new_map = copy.deepcopy(map)
    for _, status in mux_status.items():
        dut_port_index = status['port_index']
        inactive_dut_index = 0 if status['active_side'] == 'tor_b' else 1
        ptf_port_index = tbinfo['topo']['ptf_map'][str(inactive_dut_index)][str(dut_port_index)]
        if inactive_dut_index in new_map[str(ptf_port_index)]:
            new_map[str(ptf_port_index)].remove(inactive_dut_index)
    return new_map


@pytest.fixture
def ptf_port_dut_map_random_side(tbinfo, ptf_port_dut_map, ptfhost, mux_server_url):
    if 'dualtor' in tbinfo['topo']['name']:
        new_mux_status = set_dualtor_active(mux_server_url, 'random')
        ptf_port_dut_map = remove_inactive_side_dut(ptf_port_dut_map, tbinfo, new_mux_status)
    logger.info('ptf_port_dut_map={}'.format(json.dumps(ptf_port_dut_map)))
    ptfhost.copy(content=json.dumps(ptf_port_dut_map), dest=PTF_PORT_DUT_MAP_PATH)
    return PTF_PORT_DUT_MAP_PATH


@pytest.mark.parametrize("ipv4, ipv6, mtu", [pytest.param(True, True, 1514)])
def test_basic_fib(duthosts, ptfhost, ipv4, ipv6, mtu, setup_fib, ptf_port_dut_map_random_side):
    timestamp = datetime.now().strftime('%Y-%m-%d-%H:%M:%S')

    # do not test load balancing for vs platform as kernel 4.9
    # can only do load balance base on L3
    if duthosts[0].facts['asic_type'] in ["vs"]:
        test_balancing = False
    else:
        test_balancing = True

    logging.info("run ptf test")
    log_file = "/tmp/fib_test.FibTest.ipv4.{}.ipv6.{}.{}.log".format(ipv4, ipv6, timestamp)
    logging.info("PTF log file: %s" % log_file)
    ptf_runner(ptfhost,
                "ptftests",
                "fib_test.FibTest",
                platform_dir="ptftests",
                params={"setup_info": setup_fib,
                        "ptf_port_dut_map": ptf_port_dut_map_random_side,
                        "ipv4": ipv4,
                        "ipv6": ipv6,
                        "testbed_mtu": mtu,
                        "test_balancing": test_balancing },
                log_file=log_file,
                qlen=PTF_QLEN,
                socket_recv_size=16384)


def get_vlan_untag_ports(config_facts):
    """
    get all untag vlan ports
    """
    vlan_untag_ports = []
    vlans = config_facts.get('VLAN_INTERFACE', {}).keys()
    for vlan in vlans:
        vlan_member_info = config_facts.get('VLAN_MEMBER', {}).get(vlan, {})
        if vlan_member_info:
            for port_name, tag_mode in vlan_member_info.items():
                if tag_mode['tagging_mode'] == 'untagged':
                    vlan_untag_ports.append(port_name)

    return vlan_untag_ports


@pytest.fixture(scope="module")
def setup_hash(tbinfo, duthosts, config_facts):

    hash_keys = HASH_KEYS[:]    # Copy from global var to avoid side effects of multiple iterations
    if 'dst-mac' in hash_keys:
        hash_keys.remove('dst-mac')

    # do not test load balancing on L4 port on vs platform as kernel 4.9
    # can only do load balance base on L3
    if duthosts[0].facts['asic_type'] in ["vs"]:
        if 'src-port' in hash_keys:
            hash_keys.remove('src-port')
        if 'dst-port' in hash_keys:
            hash_keys.remove('dst-port')
    if duthosts[0].facts['asic_type'] in ["mellanox"]:
        if 'ip-proto' in hash_keys:
            hash_keys.remove('ip-proto')
    if duthosts[0].facts['asic_type'] in ["barefoot"]:
        if 'ingress-port' in hash_keys:
            hash_keys.remove('ingress-port')

    vlan_untag_ports = get_vlan_untag_ports(config_facts)
    for duthost in duthosts:
        # add some vlan for hash_key vlan-id test
        if tbinfo['topo']['type'] == 't0' and 'vlan-id' in hash_keys:
            for vlan in VLANIDS:
                duthost.shell('config vlan add {}'.format(vlan))
                for port in vlan_untag_ports:
                    duthost.shell('config vlan member add {} {}'.format(vlan, port))
                duthost.shell('config interface ip add Vlan{} '.format(vlan) + VLANIP.format(vlan%256))
            time.sleep(5)

    yield hash_keys

    # remove added vlan
    for duthost in duthosts:
        if 't0' in tbinfo['topo']['name'] and 'vlan-id' in hash_keys:
            for vlan in VLANIDS:
                for port in vlan_untag_ports:
                    duthost.shell('config vlan member del {} {}'.format(vlan, port))
                duthost.shell('config interface ip remove Vlan{} '.format(vlan) + VLANIP.format(vlan%256))
                duthost.shell('config vlan del {}'.format(vlan))
            time.sleep(5)


@pytest.fixture(params=["ipv4", "ipv6"])
def ipver(request):
    return request.param


@pytest.fixture
def ptf_port_dut_map_same_side(tbinfo, ptf_port_dut_map, ptfhost, mux_server_url):
    if 'dualtor' in tbinfo['topo']['name']:
        new_mux_status = set_dualtor_active(mux_server_url, random.choice(['tor_a', 'tor_b']))
        ptf_port_dut_map = remove_inactive_side_dut(ptf_port_dut_map, tbinfo, new_mux_status)
    logger.info('ptf_port_dut_map={}'.format(json.dumps(ptf_port_dut_map)))
    ptfhost.copy(content=json.dumps(ptf_port_dut_map), dest=PTF_PORT_DUT_MAP_PATH)
    return PTF_PORT_DUT_MAP_PATH


def test_hash(setup_fib, setup_hash, ptfhost, ipver, ptf_port_dut_map_same_side):
    timestamp = datetime.now().strftime('%Y-%m-%d-%H:%M:%S')
    log_file = "/tmp/hash_test.HashTest.{}.{}.log".format(ipver, timestamp)
    logging.info("PTF log file: %s" % log_file)
    if ipver == "ipv4":
        src_ip_range = SRC_IP_RANGE
        dst_ip_range = DST_IP_RANGE
    elif ipver == "ipv6":
        src_ip_range = SRC_IPV6_RANGE
        dst_ip_range = DST_IPV6_RANGE

    ptf_runner(ptfhost,
            "ptftests",
            "hash_test.HashTest",
            platform_dir="ptftests",
            params={"setup_info": setup_fib,
                    "ptf_port_dut_map": ptf_port_dut_map_same_side,
                    "hash_keys": setup_hash,
                    "src_ip_range": ",".join(src_ip_range),
                    "dst_ip_range": ",".join(dst_ip_range),
                    "vlan_ids": VLANIDS},
            log_file=log_file,
            qlen=PTF_QLEN,
            socket_recv_size=16384)
